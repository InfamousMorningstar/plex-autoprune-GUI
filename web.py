"""
Plex-Auto-Prune GUI Web Interface
A sophisticated web GUI for managing Plex user access automation
Runs alongside the daemon with a web dashboard on port 8080
"""
import os
import json
import threading
import time
from datetime import datetime, timezone, timedelta
from flask import Flask, render_template, jsonify, request, send_from_directory
from flask_socketio import SocketIO, emit
import secrets

# Import daemon module
import daemon

app = Flask(__name__)
app.secret_key = os.environ.get('SECRET_KEY', secrets.token_hex(32))
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='eventlet')

# Configuration file path
CONFIG_FILE = "/app/.env"
SETUP_FLAG = "/app/state/.setup_complete"

# In-memory log buffer for real-time streaming
log_buffer = []
MAX_LOG_BUFFER = 1000

def web_log(msg, level="INFO"):
    """Log message and broadcast to connected clients"""
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_entry = {"timestamp": ts, "level": level, "message": msg}
    log_buffer.append(log_entry)
    if len(log_buffer) > MAX_LOG_BUFFER:
        log_buffer.pop(0)
    socketio.emit('log', log_entry, namespace='/')
    print(f"[{ts}] [{level}] {msg}", flush=True)

def is_setup_complete():
    """Check if initial setup wizard has been completed"""
    return os.path.exists(SETUP_FLAG)

def mark_setup_complete():
    """Mark setup wizard as complete"""
    os.makedirs(os.path.dirname(SETUP_FLAG), exist_ok=True)
    with open(SETUP_FLAG, 'w') as f:
        f.write(datetime.now().isoformat())

def get_env_config():
    """Read current environment configuration"""
    return {
        'PLEX_TOKEN': os.environ.get('PLEX_TOKEN', ''),
        'PLEX_SERVER_NAME': os.environ.get('PLEX_SERVER_NAME', ''),
        'TAUTULLI_URL': os.environ.get('TAUTULLI_URL', ''),
        'TAUTULLI_API_KEY': os.environ.get('TAUTULLI_API_KEY', ''),
        'SMTP_HOST': os.environ.get('SMTP_HOST', 'smtp.gmail.com'),
        'SMTP_PORT': os.environ.get('SMTP_PORT', '587'),
        'SMTP_USERNAME': os.environ.get('SMTP_USERNAME', ''),
        'SMTP_PASSWORD': os.environ.get('SMTP_PASSWORD', ''),
        'SMTP_FROM': os.environ.get('SMTP_FROM', ''),
        'ADMIN_EMAIL': os.environ.get('ADMIN_EMAIL', ''),
        'DISCORD_WEBHOOK': os.environ.get('DISCORD_WEBHOOK', ''),
        'LINK_DISCORD': os.environ.get('LINK_DISCORD', ''),
        'WARN_DAYS': os.environ.get('WARN_DAYS', '27'),
        'KICK_DAYS': os.environ.get('KICK_DAYS', '30'),
        'CHECK_NEW_USERS_SECS': os.environ.get('CHECK_NEW_USERS_SECS', '120'),
        'CHECK_INACTIVITY_SECS': os.environ.get('CHECK_INACTIVITY_SECS', '1800'),
        'VIP_NAMES': os.environ.get('VIP_NAMES', ''),
        'DRY_RUN': os.environ.get('DRY_RUN', 'true')
    }

def save_env_config(config):
    """Save configuration to .env file"""
    os.makedirs(os.path.dirname(CONFIG_FILE), exist_ok=True)
    with open(CONFIG_FILE, 'w') as f:
        f.write("# Plex-Auto-Prune GUI Configuration\n")
        f.write("# Generated by Plex-Auto-Prune GUI\n\n")
        for key, value in config.items():
            if value:
                f.write(f'{key}={value}\n')
    
    # Reload environment
    daemon.load_env_file(CONFIG_FILE)

# ==================== ROUTES ====================

@app.route('/')
def index():
    """Main entry point - redirects to setup or dashboard"""
    if not is_setup_complete():
        return render_template('setup.html')
    return render_template('dashboard.html')

@app.route('/dashboard')
def dashboard():
    """Main dashboard"""
    return render_template('dashboard.html')

@app.route('/users')
def users():
    """User management page"""
    return render_template('users.html')

@app.route('/settings')
def settings():
    """Settings configuration page"""
    return render_template('settings.html')

@app.route('/logs')
def logs_page():
    """Live logs viewer"""
    return render_template('logs.html')

# ==================== API ENDPOINTS ====================

@app.route('/api/setup/complete', methods=['POST'])
def api_setup_complete():
    """Complete initial setup wizard"""
    try:
        config = request.json
        save_env_config(config)
        mark_setup_complete()
        web_log("Setup wizard completed successfully", "SUCCESS")
        return jsonify({'success': True})
    except Exception as e:
        web_log(f"Setup failed: {str(e)}", "ERROR")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/setup/status', methods=['GET'])
def api_setup_status():
    """Check if setup is complete"""
    return jsonify({'complete': is_setup_complete()})

@app.route('/api/config', methods=['GET'])
def api_get_config():
    """Get current configuration (masked sensitive values)"""
    config = get_env_config()
    # Mask sensitive data
    if config['PLEX_TOKEN'] and len(config['PLEX_TOKEN']) > 4:
        config['PLEX_TOKEN'] = '••••' + config['PLEX_TOKEN'][-4:]
    if config['SMTP_PASSWORD']:
        config['SMTP_PASSWORD'] = '••••••••'
    if config['TAUTULLI_API_KEY'] and len(config['TAUTULLI_API_KEY']) > 4:
        config['TAUTULLI_API_KEY'] = '••••' + config['TAUTULLI_API_KEY'][-4:]
    if config['DISCORD_WEBHOOK'] and len(config['DISCORD_WEBHOOK']) > 20:
        config['DISCORD_WEBHOOK'] = config['DISCORD_WEBHOOK'][:50] + '••••'
    return jsonify(config)

@app.route('/api/config', methods=['POST'])
def api_save_config():
    """Save configuration updates"""
    try:
        new_config = request.json
        current = get_env_config()
        
        # Preserve masked values
        for key in new_config:
            if new_config[key] and '••••' in str(new_config[key]):
                new_config[key] = current[key]
        
        save_env_config(new_config)
        web_log("Configuration updated", "SUCCESS")
        return jsonify({'success': True})
    except Exception as e:
        web_log(f"Config save failed: {str(e)}", "ERROR")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/stats', methods=['GET'])
def api_stats():
    """Get dashboard statistics"""
    try:
        state = daemon.load_state()
        all_users = daemon.plex_get_users()
        
        welcomed = state.get('welcomed', {})
        warned = state.get('warned', {})
        removed = state.get('removed', {})
        
        # Calculate users at risk (close to warning threshold)
        warn_days = int(os.environ.get('WARN_DAYS', 27))
        at_risk_count = 0
        
        stats = {
            'total_users': len(all_users),
            'active_users': len(welcomed) - len(warned),
            'warned_users': len(warned),
            'removed_users': len(removed),
            'at_risk_users': at_risk_count,  # Will implement proper calculation
            'dry_run_mode': os.environ.get('DRY_RUN', 'true').lower() in ('true', '1', 'yes'),
            'warn_threshold': warn_days,
            'kick_threshold': int(os.environ.get('KICK_DAYS', 30)),
            'daemon_status': 'running'  # Will add actual status check
        }
        
        return jsonify(stats)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/users', methods=['GET'])
def api_users():
    """Get list of all users with detailed status"""
    try:
        state = daemon.load_state()
        plex_users = daemon.plex_get_users()
        welcomed = state.get('welcomed', {})
        warned = state.get('warned', {})
        removed = state.get('removed', {})
        
        vip_names = os.environ.get('VIP_NAMES', '').lower().split(',')
        vip_names = [n.strip() for n in vip_names if n.strip()]
        
        users_data = []
        
        for user in plex_users:
            uid = str(user['id'])
            username = (user['username'] or '').lower()
            
            # Determine user status
            if uid in removed:
                status = 'removed'
                badge_class = 'danger'
            elif uid in warned:
                status = 'warned'
                badge_class = 'warning'
            elif uid in welcomed:
                status = 'active'
                badge_class = 'success'
            else:
                status = 'new'
                badge_class = 'info'
            
            # Check VIP status
            is_vip = username in vip_names
            
            # Get last activity
            last_watch = None
            days_inactive = None
            try:
                t_users = daemon.tautulli('get_users')
                for tu in t_users:
                    if (tu.get('email', '') or '').lower() == (user['email'] or '').lower():
                        last_watch = daemon.tautulli_last_watch(tu.get('user_id'))
                        if last_watch:
                            days_inactive = (datetime.now(timezone.utc) - last_watch).days
                        break
            except:
                pass
            
            users_data.append({
                'id': uid,
                'name': user['title'] or user['username'] or 'Unknown',
                'email': user['email'] or '',
                'username': user['username'] or '',
                'status': status,
                'badge_class': badge_class,
                'is_vip': is_vip,
                'last_watch': last_watch.isoformat() if last_watch else None,
                'days_inactive': days_inactive,
                'welcomed_at': welcomed.get(uid),
                'warned_at': warned.get(uid),
                'removed_info': removed.get(uid)
            })
        
        return jsonify(users_data)
    except Exception as e:
        web_log(f"Error fetching users: {str(e)}", "ERROR")
        return jsonify({'error': str(e)}), 500

@app.route('/api/users/<user_id>/welcome', methods=['POST'])
def api_user_welcome(user_id):
    """Send welcome email to user"""
    try:
        users = daemon.plex_get_users()
        user = next((u for u in users if str(u['id']) == user_id), None)
        
        if not user:
            return jsonify({'error': 'User not found'}), 404
        
        display = user['title'] or user['username'] or 'there'
        email = user['email']
        
        if not email:
            return jsonify({'error': 'User has no email address'}), 400
        
        daemon.send_email(email, "Access confirmed", daemon.welcome_email_html(display))
        
        # Update state
        state = daemon.load_state()
        state['welcomed'][user_id] = datetime.now(timezone.utc).isoformat()
        daemon.save_state(state)
        
        web_log(f"Welcome email sent to {display} ({email})", "SUCCESS")
        return jsonify({'success': True})
    except Exception as e:
        web_log(f"Welcome email failed: {str(e)}", "ERROR")
        return jsonify({'error': str(e)}), 500

@app.route('/api/users/<user_id>/warn', methods=['POST'])
def api_user_warn(user_id):
    """Send warning email to user"""
    try:
        users = daemon.plex_get_users()
        user = next((u for u in users if str(u['id']) == user_id), None)
        
        if not user:
            return jsonify({'error': 'User not found'}), 404
        
        display = user['title'] or user['username'] or 'there'
        email = user['email']
        days = int(request.json.get('days', 28))
        
        if not email:
            return jsonify({'error': 'User has no email address'}), 400
        
        daemon.send_email(email, "Warning: Account inactivity", daemon.warn_email_html(display, days))
        
        # Update state
        state = daemon.load_state()
        state['warned'][user_id] = datetime.now(timezone.utc).isoformat()
        daemon.save_state(state)
        
        web_log(f"Warning email sent to {display} ({email})", "SUCCESS")
        return jsonify({'success': True})
    except Exception as e:
        web_log(f"Warning email failed: {str(e)}", "ERROR")
        return jsonify({'error': str(e)}), 500

@app.route('/api/users/<user_id>/remove', methods=['POST'])
def api_user_remove(user_id):
    """Remove user from Plex"""
    try:
        users = daemon.plex_get_users()
        user = next((u for u in users if str(u['id']) == user_id), None)
        
        if not user:
            return jsonify({'error': 'User not found'}), 404
        
        display = user['title'] or user['username'] or 'there'
        email = user['email']
        
        # Attempt removal
        ok = daemon.remove_friend(daemon.get_plex_account(), user_id)
        
        if ok and email:
            daemon.send_email(email, "Access revoked", daemon.removal_email_html(display))
        
        # Update state
        state = daemon.load_state()
        state['removed'][user_id] = {
            'ok': ok,
            'reason': 'Manual removal via web interface',
            'when': datetime.now(timezone.utc).isoformat()
        }
        state['welcomed'].pop(user_id, None)
        state['warned'].pop(user_id, None)
        daemon.save_state(state)
        
        web_log(f"User removed: {display} - {'success' if ok else 'failed'}", "WARNING" if ok else "ERROR")
        return jsonify({'success': ok})
    except Exception as e:
        web_log(f"User removal failed: {str(e)}", "ERROR")
        return jsonify({'error': str(e)}), 500

@app.route('/api/users/<user_id>/reset', methods=['POST'])
def api_user_reset(user_id):
    """Reset user state (clear warnings/removals)"""
    try:
        state = daemon.load_state()
        state['warned'].pop(user_id, None)
        state['removed'].pop(user_id, None)
        daemon.save_state(state)
        
        web_log(f"User state reset for user ID {user_id}", "INFO")
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/users/<user_id>/vip', methods=['POST'])
def api_user_toggle_vip(user_id):
    """Add or remove user from VIP list"""
    try:
        users = daemon.plex_get_users()
        user = next((u for u in users if str(u['id']) == user_id), None)
        
        if not user or not user['username']:
            return jsonify({'error': 'User not found or has no username'}), 404
        
        config = get_env_config()
        vip_names = [n.strip() for n in config['VIP_NAMES'].split(',') if n.strip()]
        username = user['username']
        
        if username in vip_names:
            vip_names.remove(username)
            action = "removed from"
        else:
            vip_names.append(username)
            action = "added to"
        
        config['VIP_NAMES'] = ','.join(vip_names)
        save_env_config(config)
        
        web_log(f"User {username} {action} VIP list", "INFO")
        return jsonify({'success': True, 'is_vip': username in vip_names})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/test/email', methods=['POST'])
def api_test_email():
    """Send test email"""
    try:
        email = request.json.get('email')
        if not email:
            return jsonify({'error': 'Email required'}), 400
        
        daemon.send_email(email, "Plex-Auto-Prune GUI Test Email", daemon.welcome_email_html("Test User"))
        web_log(f"Test email sent to {email}", "SUCCESS")
        return jsonify({'success': True})
    except Exception as e:
        web_log(f"Test email failed: {str(e)}", "ERROR")
        return jsonify({'error': str(e)}), 500

@app.route('/api/test/discord', methods=['POST'])
def api_test_discord():
    """Send test Discord notifications"""
    try:
        daemon.test_discord_notifications()
        web_log("Test Discord notifications sent", "SUCCESS")
        return jsonify({'success': True})
    except Exception as e:
        web_log(f"Discord test failed: {str(e)}", "ERROR")
        return jsonify({'error': str(e)}), 500

@app.route('/api/test/plex', methods=['POST'])
def api_test_plex():
    """Test Plex connection"""
    try:
        acct = daemon.get_plex_account()
        users = daemon.plex_get_users()
        web_log(f"Plex connection successful: {len(users)} users", "SUCCESS")
        return jsonify({
            'success': True,
            'username': acct.username,
            'email': acct.email,
            'user_count': len(users)
        })
    except Exception as e:
        web_log(f"Plex connection failed: {str(e)}", "ERROR")
        return jsonify({'error': str(e)}), 500

@app.route('/api/test/tautulli', methods=['POST'])
def api_test_tautulli():
    """Test Tautulli connection"""
    try:
        users = daemon.tautulli('get_users')
        web_log(f"Tautulli connection successful: {len(users)} users", "SUCCESS")
        return jsonify({
            'success': True,
            'user_count': len(users)
        })
    except Exception as e:
        web_log(f"Tautulli connection failed: {str(e)}", "ERROR")
        return jsonify({'error': str(e)}), 500

@app.route('/api/logs', methods=['GET'])
def api_get_logs():
    """Get log history"""
    return jsonify({'logs': log_buffer})

# ==================== WEBSOCKET EVENTS ====================

@socketio.on('connect')
def handle_connect():
    """Handle client connection - send log history"""
    emit('log_history', {'logs': log_buffer})
    web_log("Web client connected", "INFO")

@socketio.on('disconnect')
def handle_disconnect():
    """Handle client disconnection"""
    web_log("Web client disconnected", "INFO")

# ==================== STARTUP ====================

if __name__ == '__main__':
    web_log("=" * 60, "INFO")
    web_log("Plex-Auto-Prune GUI Starting", "INFO")
    web_log("Web UI will be available at http://0.0.0.0:8080", "INFO")
    web_log("=" * 60, "INFO")
    
    # Run web server
    socketio.run(app, host='0.0.0.0', port=8080, debug=False, allow_unsafe_werkzeug=True)
